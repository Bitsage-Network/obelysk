// SPDX-License-Identifier: BUSL-1.1
// Copyright (c) 2025 BitSage Network Foundation
//
// Obelysk Stealth Payment System
// Implements stealth addresses for unlinkable worker payments
//
// Based on EIP-5564 stealth address standard adapted for Starknet
//
// Privacy Model:
// - Workers publish a "meta-address" (spending key + viewing key)
// - Clients derive one-time stealth addresses for payments
// - On-chain observers cannot link payments to worker identities
// - Workers scan for payments using their viewing key
// - Workers claim using derived spending key
//
// Cryptographic Scheme:
// - Uses STARK-friendly curve (same as Starknet native)
// - ECDH for shared secret derivation
// - Pedersen hash for address derivation
// - Schnorr proofs for spending authorization

use starknet::ContractAddress;
use core::poseidon::poseidon_hash_span;
use sage_contracts::obelysk::elgamal::{
    ECPoint, ElGamalCiphertext,
    ec_mul, ec_add,
    generator, generator_h,
    mul_mod_n, add_mod_n,
};

// ============================================================================
// STEALTH ADDRESS STRUCTURES
// ============================================================================

/// Worker's stealth meta-address (published on-chain)
/// Contains two public keys: one for spending, one for viewing
#[derive(Copy, Drop, Serde, starknet::Store)]
pub struct StealthMetaAddress {
    /// Spending public key: PK_spend = sk_spend * G
    /// Used to derive the final stealth address
    pub spending_pubkey: ECPoint,
    /// Viewing public key: PK_view = sk_view * G
    /// Used by worker to scan for incoming payments
    pub viewing_pubkey: ECPoint,
    /// Optional: scheme identifier for future extensibility
    pub scheme_id: u8,
}

/// Stealth payment announcement (stored on-chain)
/// Contains ephemeral key and payment details
#[derive(Copy, Drop, Serde, starknet::Store)]
pub struct StealthPaymentAnnouncement {
    /// Ephemeral public key: R = r * G
    /// Worker uses this with viewing key to find payments
    pub ephemeral_pubkey: ECPoint,
    /// The derived stealth address receiving the payment
    pub stealth_address: felt252,
    /// Encrypted payment amount (optional, for privacy)
    pub encrypted_amount: ElGamalCiphertext,
    /// View tag: first byte of shared secret for fast scanning
    pub view_tag: u8,
    /// Timestamp of payment
    pub timestamp: u64,
    /// Associated job ID (0 if direct transfer)
    pub job_id: u256,
    /// Token contract address for this payment
    pub token: ContractAddress,
}

/// Spending proof for claiming stealth payments
#[derive(Copy, Drop, Serde)]
pub struct StealthSpendingProof {
    /// Commitment: R_proof = k * G
    pub commitment: ECPoint,
    /// Challenge: e = H(stealth_addr, R_proof, message)
    pub challenge: felt252,
    /// Response: s = k + e * sk_stealth
    pub response: felt252,
    /// The stealth public key being proven
    pub stealth_pubkey: ECPoint,
}

/// Result of scanning for stealth payments
#[derive(Copy, Drop, Serde)]
pub struct ScannedPayment {
    /// Index in the announcements array
    pub announcement_index: u32,
    /// The stealth address
    pub stealth_address: felt252,
    /// Derived spending key for this payment
    pub spending_key: felt252,
    /// Decrypted amount (if worker has viewing key)
    pub amount: u256,
    /// Whether already claimed
    pub is_claimed: bool,
}

/// Worker stealth keypair (kept off-chain by worker)
#[derive(Copy, Drop, Serde)]
pub struct StealthKeypair {
    /// Spending secret key
    pub spending_key: felt252,
    /// Viewing secret key
    pub viewing_key: felt252,
    /// Derived meta-address
    pub meta_address: StealthMetaAddress,
}

// ============================================================================
// STEALTH ADDRESS MATHEMATICS
// ============================================================================

/// Generate a stealth keypair from two secrets
/// @param spending_secret: Secret for spending (keep very secure)
/// @param viewing_secret: Secret for viewing (can be on hot wallet)
/// @return Complete stealth keypair with meta-address
pub fn generate_stealth_keypair(
    spending_secret: felt252,
    viewing_secret: felt252
) -> StealthKeypair {
    let g = generator();

    // Derive public keys
    let spending_pubkey = ec_mul(spending_secret, g);
    let viewing_pubkey = ec_mul(viewing_secret, g);

    let meta_address = StealthMetaAddress {
        spending_pubkey,
        viewing_pubkey,
        scheme_id: 1, // Scheme 1: ECDH + Pedersen
    };

    StealthKeypair {
        spending_key: spending_secret,
        viewing_key: viewing_secret,
        meta_address,
    }
}

/// Derive a stealth address from a meta-address (sender side)
/// @param meta_address: Worker's published meta-address
/// @param ephemeral_secret: Random secret generated by sender (r)
/// @return (stealth_address, ephemeral_pubkey, view_tag)
pub fn derive_stealth_address(
    meta_address: StealthMetaAddress,
    ephemeral_secret: felt252
) -> (felt252, ECPoint, u8) {
    let g = generator();

    // Step 1: Compute ephemeral public key R = r * G
    let ephemeral_pubkey = ec_mul(ephemeral_secret, g);

    // Step 2: Compute shared secret S = r * PK_view
    let shared_secret_point = ec_mul(ephemeral_secret, meta_address.viewing_pubkey);

    // Step 3: Derive view tag (first byte of hash for fast scanning)
    let view_tag = compute_view_tag(shared_secret_point);

    // Step 4: Compute stealth public key
    // PK_stealth = PK_spend + H(S) * G
    let shared_secret_scalar = hash_point_to_scalar(shared_secret_point);
    let offset_point = ec_mul(shared_secret_scalar, g);
    let stealth_pubkey = ec_add(meta_address.spending_pubkey, offset_point);

    // Step 5: Derive stealth address from stealth public key
    let stealth_address = pubkey_to_address(stealth_pubkey);

    (stealth_address, ephemeral_pubkey, view_tag)
}

/// Check if a payment is for us (recipient side - fast check using view tag)
/// @param viewing_key: Worker's viewing secret key
/// @param ephemeral_pubkey: R from the announcement
/// @param view_tag: View tag from the announcement
/// @return true if view tag matches (payment might be for us)
pub fn check_view_tag(
    viewing_key: felt252,
    ephemeral_pubkey: ECPoint,
    view_tag: u8
) -> bool {
    // Compute shared secret S = vk * R
    let shared_secret_point = ec_mul(viewing_key, ephemeral_pubkey);

    // Compute expected view tag
    let expected_tag = compute_view_tag(shared_secret_point);

    view_tag == expected_tag
}

/// Derive the stealth spending key (recipient side)
/// @param spending_key: Worker's spending secret key
/// @param viewing_key: Worker's viewing secret key
/// @param ephemeral_pubkey: R from the announcement
/// @return The derived stealth spending key for this specific payment
pub fn derive_stealth_spending_key(
    spending_key: felt252,
    viewing_key: felt252,
    ephemeral_pubkey: ECPoint
) -> felt252 {
    // Compute shared secret S = vk * R
    let shared_secret_point = ec_mul(viewing_key, ephemeral_pubkey);

    // Derive stealth spending key
    // sk_stealth = sk_spend + H(S)  (mod N, curve order)
    let shared_secret_scalar = hash_point_to_scalar(shared_secret_point);

    // CRITICAL: Must use mod N (curve order), NOT felt252 mod P (field prime).
    // Raw felt252 + wraps mod P which differs from N by ~2^192. If the sum
    // exceeds N but stays below P, the derived key is invalid for EC operations.
    add_mod_n(spending_key, shared_secret_scalar)
}

/// Verify that a stealth address matches expected derivation (PUBLIC verification)
/// @param meta_address: Worker's meta-address
/// @param ephemeral_pubkey: R from the announcement
/// @param claimed_stealth_address: The address being verified
/// @return true if basic sanity checks pass
///
/// NOTE: Full cryptographic verification is NOT possible without the viewing key.
/// This function only validates structural correctness. For full verification:
/// - Use `verify_stealth_address_with_viewing_key` if you have the viewing key
/// - Otherwise, rely on spending proof verification during claim
pub fn verify_stealth_address(
    meta_address: StealthMetaAddress,
    ephemeral_pubkey: ECPoint,
    claimed_stealth_address: felt252
) -> bool {
    // Sanity check 1: Stealth address must be non-zero
    if claimed_stealth_address == 0 {
        return false;
    }

    // Sanity check 2: Ephemeral pubkey must be non-zero (valid point)
    if is_point_zero(ephemeral_pubkey) {
        return false;
    }

    // Sanity check 3: Meta-address must have valid public keys
    if is_point_zero(meta_address.spending_pubkey) {
        return false;
    }
    if is_point_zero(meta_address.viewing_pubkey) {
        return false;
    }

    // Sanity check 4: Scheme must be supported
    if meta_address.scheme_id != 1 {
        return false;
    }

    // All sanity checks passed
    // Full cryptographic verification happens during claim with spending proof
    true
}

/// Verify stealth address with viewing key (FULL cryptographic verification)
/// @param meta_address: Worker's meta-address
/// @param viewing_key: Worker's viewing secret key (must be kept private)
/// @param ephemeral_pubkey: R from the announcement
/// @param claimed_stealth_address: The address being verified
/// @return true if the stealth address was correctly derived
pub fn verify_stealth_address_with_viewing_key(
    meta_address: StealthMetaAddress,
    viewing_key: felt252,
    ephemeral_pubkey: ECPoint,
    claimed_stealth_address: felt252
) -> bool {
    let g = generator();

    // Step 1: Compute shared secret S = vk * R
    let shared_secret_point = ec_mul(viewing_key, ephemeral_pubkey);

    // Step 2: Derive the expected stealth public key
    // PK_stealth = PK_spend + H(S) * G
    let shared_secret_scalar = hash_point_to_scalar(shared_secret_point);
    let offset_point = ec_mul(shared_secret_scalar, g);
    let expected_stealth_pubkey = ec_add(meta_address.spending_pubkey, offset_point);

    // Step 3: Convert to address
    let expected_stealth_address = pubkey_to_address(expected_stealth_pubkey);

    // Step 4: Verify match
    expected_stealth_address == claimed_stealth_address
}

/// Check if an EC point is the zero point
fn is_point_zero(point: ECPoint) -> bool {
    // A point is zero if both coordinates are zero
    point.x == 0 && point.y == 0
}

/// Create a spending proof for claiming a stealth payment
/// @param stealth_spending_key: The derived spending key for this payment
/// @param stealth_address: The stealth address being claimed
/// @param nonce: Random nonce for the proof
/// @return Schnorr-style spending proof
pub fn create_spending_proof(
    stealth_spending_key: felt252,
    stealth_address: felt252,
    nonce: felt252
) -> StealthSpendingProof {
    let g = generator();

    // Compute stealth public key from spending key
    let stealth_pubkey = ec_mul(stealth_spending_key, g);

    // Step 1: Commitment R = k * G
    let commitment = ec_mul(nonce, g);

    // Step 2: Challenge e = H(stealth_addr, R, PK_stealth)
    let challenge = compute_spending_challenge(stealth_address, commitment, stealth_pubkey);

    // Step 3: Response s = k + e * sk_stealth (mod curve_order)
    // CRITICAL: Must use curve-order modular arithmetic, not felt252 arithmetic.
    // felt252 arithmetic is mod P (field prime), but Schnorr requires mod N (curve order).
    let e_times_sk = mul_mod_n(challenge, stealth_spending_key);
    let response = add_mod_n(nonce, e_times_sk);

    StealthSpendingProof {
        commitment,
        challenge,
        response,
        stealth_pubkey,
    }
}

/// Verify a spending proof
/// @param proof: The spending proof to verify
/// @param stealth_address: The claimed stealth address
/// @return true if proof is valid
pub fn verify_spending_proof(
    proof: StealthSpendingProof,
    stealth_address: felt252
) -> bool {
    let g = generator();

    // Verify: s * G == R + e * PK_stealth
    let lhs = ec_mul(proof.response, g);
    let e_times_pk = ec_mul(proof.challenge, proof.stealth_pubkey);
    let rhs = ec_add(proof.commitment, e_times_pk);

    // Check point equality using .x and .y fields
    if lhs.x != rhs.x || lhs.y != rhs.y {
        return false;
    }

    // Verify challenge was computed correctly
    let expected_challenge = compute_spending_challenge(
        stealth_address,
        proof.commitment,
        proof.stealth_pubkey
    );

    if proof.challenge != expected_challenge {
        return false;
    }

    // Verify stealth address matches stealth pubkey
    let derived_address = pubkey_to_address(proof.stealth_pubkey);

    derived_address == stealth_address
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/// Compute view tag from shared secret point (first byte of hash)
fn compute_view_tag(shared_secret: ECPoint) -> u8 {
    let hash = hash_point_to_scalar(shared_secret);
    // Extract first byte (simplified)
    let hash_u256: u256 = hash.into();
    let first_byte: u8 = (hash_u256 % 256).try_into().unwrap();
    first_byte
}

/// Hash a point to a scalar (for key derivation)
fn hash_point_to_scalar(point: ECPoint) -> felt252 {
    let mut input: Array<felt252> = array![];
    input.append(point.x);
    input.append(point.y);
    input.append('stealth_derive'); // Domain separator

    poseidon_hash_span(input.span())
}

/// Derive a contract address from a public key
fn pubkey_to_address(pubkey: ECPoint) -> felt252 {
    let mut input: Array<felt252> = array![];
    input.append(pubkey.x);
    input.append(pubkey.y);
    input.append('stealth_address'); // Domain separator

    poseidon_hash_span(input.span())
}

/// Compute spending proof challenge
fn compute_spending_challenge(
    stealth_address: felt252,
    commitment: ECPoint,
    stealth_pubkey: ECPoint
) -> felt252 {
    let mut input: Array<felt252> = array![];
    input.append(stealth_address);
    input.append(commitment.x);
    input.append(commitment.y);
    input.append(stealth_pubkey.x);
    input.append(stealth_pubkey.y);
    input.append('spending_challenge'); // Domain separator

    poseidon_hash_span(input.span())
}

/// Encrypt amount to stealth recipient using their stealth public key
pub fn encrypt_amount_to_stealth(
    amount: u256,
    stealth_pubkey: ECPoint,
    randomness: felt252
) -> ElGamalCiphertext {
    let g = generator();
    let h = generator_h();

    // C1 = r * G
    let c1 = ec_mul(randomness, g);

    // C2 = amount * H + r * PK_stealth
    let amount_felt: felt252 = amount.try_into().unwrap_or(0);
    let amount_point = ec_mul(amount_felt, h);
    let mask = ec_mul(randomness, stealth_pubkey);
    let c2 = ec_add(amount_point, mask);

    // Return flat structure
    ElGamalCiphertext {
        c1_x: c1.x,
        c1_y: c1.y,
        c2_x: c2.x,
        c2_y: c2.y,
    }
}

// ============================================================================
// BATCH SCANNING HELPERS
// ============================================================================

/// Batch scan parameters for efficient payment discovery
#[derive(Copy, Drop, Serde)]
pub struct ScanParams {
    pub viewing_key: felt252,
    pub spending_key: felt252,
    pub start_index: u32,
    pub batch_size: u32,
}

/// Result of a batch scan
#[derive(Drop, Serde)]
pub struct ScanResult {
    pub found_payments: Array<ScannedPayment>,
    pub last_scanned_index: u32,
    pub total_amount: u256,
}

/// Check multiple announcements efficiently using view tags
/// This is a helper for off-chain scanning - actual scanning
/// would typically happen off-chain for efficiency
pub fn batch_check_view_tags(
    viewing_key: felt252,
    announcements: Array<StealthPaymentAnnouncement>
) -> Array<u32> {
    let mut matching_indices: Array<u32> = array![];
    let len = announcements.len();
    let mut i: u32 = 0;

    loop {
        if i >= len {
            break;
        }

        let announcement = *announcements.at(i);
        if check_view_tag(viewing_key, announcement.ephemeral_pubkey, announcement.view_tag) {
            matching_indices.append(i);
        }

        i += 1;
    };

    matching_indices
}
