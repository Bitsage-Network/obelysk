# Implementation Plan: VM31 M31-Native Privacy Protocol

> **Status**: Implementation Roadmap
> **Date**: 2026-02-13
> **Companion Docs**: [vm31-vision.md](./vm31-vision.md), [crypto-primitives-m31.md](./crypto-primitives-m31.md), [privacy-architecture.md](./privacy-architecture.md), [batch-proving-economics.md](./batch-proving-economics.md)
> **Codebase**: `/Users/vaamx/bitsage-network/libs/stwo-ml/` (prover), `/Users/vaamx/bitsage-network/Obelysk-Protocol/` (contracts)

---

## 1. Overview

This plan details the phased implementation of the VM31 privacy protocol — from M31-native crypto primitives through on-chain deployment. Each phase is self-contained with clear deliverables and test milestones.

**Existing infrastructure** (already built in stwo-ml):
- GKR prover with 9 gate types (MatMul, Mul, Add, AddConst, ReLU, Activation, LayerNorm, Identity, Dequantize)
- GPU CUDA kernels for M31 arithmetic (restrict, GEMM, forward ops)
- SIMD batch proving pipeline
- Poseidon-M31 channel (Fiat-Shamir)
- On-chain STARK verifier (deployed on Starknet Sepolia)
- LogUp activation/range proofs
- Recursive STARK verification (9-tx multi-step verified)

**What needs to be built**:
- Poseidon-M31 hash function (sponge mode, as a provable circuit)
- Commitment, nullifier, encryption primitives (over M31)
- UTXO pool circuit (spend proof)
- Batch proving wrapper for privacy transactions
- Starknet pool contract
- Relayer service

---

## 2. Phase 1: Poseidon-M31 Hash Circuit

**Goal**: Implement Poseidon-M31 as a provable GKR circuit — the foundation for all crypto primitives.

### 2.1 Files to Create/Modify

| File | Action | Description |
|---|---|---|
| `stwo-ml/src/crypto/poseidon_m31.rs` | Create | Poseidon-M31 permutation (plain Rust, not circuit) |
| `stwo-ml/src/circuits/mod.rs` | Create | Circuit module root |
| `stwo-ml/src/circuits/poseidon_circuit.rs` | Create | Poseidon-M31 as GKR circuit layers |
| `stwo-ml/src/lib.rs` | Modify | Add `pub mod circuits;` |

### 2.2 Poseidon-M31 Permutation

Parameters (from m31-field-analysis.md):

```
State width: t = 16 (M31 elements)
Rate: r = 12
Capacity: c = 4
S-box: x^5 (3 Mul gates per S-box)
Full rounds: R_f = 8 (4 before partial, 4 after)
Partial rounds: R_p = 14
MDS matrix: 16x16 circulant over M31
Output: 4 M31 elements (capacity portion)
```

Implementation:

```rust
// Plain evaluation (for testing and witness generation)
pub fn poseidon_m31_permutation(state: &mut [M31; 16]) {
    for r in 0..4 { full_round(state, r); }
    for r in 0..14 { partial_round(state, r); }
    for r in 0..4 { full_round(state, r + 4); }
}

// Sponge construction
pub fn poseidon_m31_hash(inputs: &[M31]) -> [M31; 4] {
    let mut state = [M31::zero(); 16];
    for chunk in inputs.chunks(12) {
        for (i, &v) in chunk.iter().enumerate() {
            state[i] += v;   // absorb into rate portion
        }
        poseidon_m31_permutation(&mut state);
    }
    [state[12], state[13], state[14], state[15]]  // squeeze from capacity
}
```

### 2.3 GKR Circuit Mapping

Each Poseidon round maps to GKR layers:

| Round Operation | GKR Gate Type | Gates per Full Round | Gates per Partial Round |
|---|---|---|---|
| Add round constant | AddConst | 16 | 1 |
| S-box (x^5) | Mul (3 per S-box) | 48 (16 S-boxes) | 3 (1 S-box) |
| MDS multiply | MatMul | 1 (16x16 matrix) | 1 (16x16 matrix) |

Total per Poseidon call: 8 full rounds (64 + 384 + 8 MDS) + 14 partial (14 + 42 + 14 MDS) = **526 gates, ~5,632 M31 muls**.

### 2.4 Deliverables

- [ ] `poseidon_m31_permutation()` — plain Rust, tested against reference vectors
- [ ] `poseidon_m31_hash()` — sponge mode for variable-length input
- [ ] `PoseidonCircuit::build(input_count: usize) -> Vec<LayerType>` — GKR circuit builder
- [ ] `test_poseidon_m31_consistency` — circuit output matches plain evaluation
- [ ] `test_poseidon_m31_collision_resistance` — statistical test on output distribution

### 2.5 MDS Matrix Generation

The MDS matrix must be generated deterministically and verified for security:

```rust
// Circulant MDS: M[i][j] = c[(j - i) mod 16]
// First row generated by Poseidon reference implementation
const MDS_FIRST_ROW: [M31; 16] = [...]; // To be derived

pub fn mds_multiply(state: &mut [M31; 16]) {
    let input = *state;
    for i in 0..16 {
        state[i] = M31::zero();
        for j in 0..16 {
            state[i] += MDS_FIRST_ROW[(j + 16 - i) % 16] * input[j];
        }
    }
}
```

**Security requirement**: The MDS matrix must have no zero entries and maximum branch number. Use the Cauchy construction method from the Poseidon paper.

### 2.6 Round Constant Generation

```rust
// Round constants via SHAKE-256 (deterministic, nothing-up-my-sleeve)
pub fn generate_round_constants() -> Vec<[M31; 16]> {
    let seed = b"Poseidon-M31-t16-d5-Rf8-Rp14";
    // SHAKE-256(seed) → stream of M31 elements
    // (8 full + 14 partial) × 16 = 352 constants
}
```

---

## 3. Phase 2: Crypto Primitives

**Goal**: Build commitment, nullifier, range proof, and encryption primitives using Poseidon-M31.

### 3.1 Files to Create

| File | Action | Description |
|---|---|---|
| `stwo-ml/src/crypto/commitment.rs` | Create | Poseidon-M31 commitments |
| `stwo-ml/src/crypto/nullifier.rs` | Create | Nullifier derivation |
| `stwo-ml/src/crypto/range_proof.rs` | Create | Bit decomposition + LogUp range proof |
| `stwo-ml/src/crypto/encryption.rs` | Create | Poseidon-based symmetric encryption |
| `stwo-ml/src/crypto/merkle_m31.rs` | Create | Poseidon-M31 Merkle tree |
| `stwo-ml/src/crypto/mod.rs` | Modify | Export new modules |

### 3.2 Commitment Scheme

```rust
pub struct NoteCommitment {
    pub value: [M31; 4],  // QM31 output
}

impl NoteCommitment {
    pub fn compute(
        owner_pubkey: &[M31; 4],
        asset_id: M31,
        amount: M31,
        blinding: &[M31; 4],
    ) -> Self {
        let input = [
            owner_pubkey[0], owner_pubkey[1], owner_pubkey[2], owner_pubkey[3],
            asset_id, amount,
            blinding[0], blinding[1], blinding[2], blinding[3],
            M31::zero(), M31::zero(), // padding to rate=12
        ];
        NoteCommitment { value: poseidon_m31_hash(&input) }
    }
}
```

### 3.3 Range Proof Circuit

Reuse the existing LogUp infrastructure from `components/activation.rs`:

```rust
// Bit decomposition: value = Σ b_i * 2^i, each b_i ∈ {0, 1}
// LogUp table: {0, 1} (2 entries)
// One LogUp lookup per bit → 31 lookups for M31 range
pub fn build_range_proof_circuit(bit_width: usize) -> Vec<LayerType> {
    // 1. Decompose value into bits (Add gates for bit recombination check)
    // 2. LogUp lookup for each bit (reuse ActivationEval with 2-entry table)
    // 3. Verify sum: Σ b_i * 2^i == original value
}
```

### 3.4 Merkle Tree

```rust
pub struct PoseidonMerkleTree {
    depth: usize,
    leaves: Vec<[M31; 4]>,
    nodes: Vec<Vec<[M31; 4]>>,  // nodes[level][index]
}

impl PoseidonMerkleTree {
    pub fn new(depth: usize) -> Self { ... }
    pub fn append(&mut self, leaf: [M31; 4]) { ... }
    pub fn root(&self) -> [M31; 4] { ... }
    pub fn prove(&self, index: usize) -> MerklePath { ... }
    pub fn verify(root: &[M31; 4], leaf: &[M31; 4], path: &MerklePath) -> bool { ... }
}
```

### 3.5 Deliverables

- [ ] `NoteCommitment::compute()` — tested for determinism and hiding
- [ ] `Nullifier::derive()` — tested for uniqueness and unlinkability
- [ ] `range_proof_circuit()` — proves value in [0, 2^n) via LogUp
- [ ] `PoseidonEncrypt/Decrypt` — counter-mode encryption over Poseidon
- [ ] `PoseidonMerkleTree` — append-only tree with proof generation/verification
- [ ] Cross-tests: circuit evaluation matches plain computation for all primitives

---

## 4. Phase 3: Spend Circuit

**Goal**: Compose primitives into a complete spend proof circuit proven via GKR.

### 4.1 Files to Create

| File | Action | Description |
|---|---|---|
| `stwo-ml/src/circuits/spend.rs` | Create | Spend proof circuit composition |
| `stwo-ml/src/circuits/deposit.rs` | Create | Deposit proof circuit |
| `stwo-ml/src/circuits/withdraw.rs` | Create | Withdrawal proof circuit |

### 4.2 Spend Circuit Composition

```rust
pub struct SpendCircuit {
    num_inputs: usize,   // typically 2
    num_outputs: usize,  // typically 2
    merkle_depth: usize, // typically 20
    with_asp: bool,      // ASP compliance proof
}

impl SpendCircuit {
    pub fn build(&self) -> ComputationGraph {
        let mut graph = GraphBuilder::new();

        // Per input note:
        for i in 0..self.num_inputs {
            // 1. Poseidon hash to verify commitment
            graph.poseidon_m31(10);  // owner(4) + asset(1) + amount(1) + blinding(4)
            // 2. Poseidon hash for nullifier
            graph.poseidon_m31(8);   // spending_key(4) + commitment(4)
            // 3. Merkle path verification (20 Poseidon hashes)
            for _ in 0..self.merkle_depth {
                graph.poseidon_m31(8); // sibling(4) + current(4)
            }
            // 4. Ownership: hash(spending_key) == owner_pubkey
            graph.poseidon_m31(4);
        }

        // Per output note:
        for o in 0..self.num_outputs {
            // 5. Poseidon hash for new commitment
            graph.poseidon_m31(10);
            // 6. Range proof on amount
            graph.range_proof(31);  // M31 range
        }

        // 7. Balance check: sum(input_amounts) == sum(output_amounts)
        graph.balance_check(self.num_inputs, self.num_outputs);

        // 8. Optional ASP membership
        if self.with_asp {
            for _ in 0..self.merkle_depth {
                graph.poseidon_m31(8);
            }
        }

        graph.build()
    }
}
```

### 4.3 Witness Generation

```rust
pub struct SpendWitness {
    pub input_notes: Vec<NotePreimage>,
    pub input_merkle_paths: Vec<MerklePath>,
    pub spending_keys: Vec<[M31; 4]>,
    pub output_notes: Vec<NotePreimage>,
    pub asp_paths: Option<Vec<MerklePath>>,
}

impl SpendWitness {
    pub fn generate_trace(&self, circuit: &SpendCircuit) -> Vec<Vec<M31>> {
        // Walk through circuit layers, computing each gate's output
        // Returns full execution trace for GKR proving
    }
}
```

### 4.4 Deliverables

- [ ] `SpendCircuit::build()` — GKR circuit for 2-in/2-out spend
- [ ] `SpendWitness::generate_trace()` — execution trace from private witness
- [ ] `prove_spend()` — full GKR proof of spend transaction
- [ ] `verify_spend()` — GKR verification of spend proof
- [ ] `test_spend_valid` — honest spend passes verification
- [ ] `test_spend_wrong_nullifier` — tampered nullifier fails
- [ ] `test_spend_wrong_merkle_root` — wrong tree root fails
- [ ] `test_spend_balance_mismatch` — input != output fails
- [ ] `test_spend_double_spend` — same nullifier twice fails

---

## 5. Phase 4: Batch Proving Pipeline

**Goal**: Batch multiple spend proofs into a single STARK proof using the existing GKR pipeline.

### 5.1 Files to Create/Modify

| File | Action | Description |
|---|---|---|
| `stwo-ml/src/circuits/batch.rs` | Create | Batch proving wrapper |
| `stwo-ml/src/aggregation.rs` | Modify | Add privacy batch to aggregation pipeline |

### 5.2 Batch Architecture

```rust
pub struct PrivacyBatch {
    pub transactions: Vec<(SpendCircuit, SpendWitness)>,
}

impl PrivacyBatch {
    pub fn prove(&self) -> BatchProof {
        // 1. Build combined circuit (all txs share same structure)
        // 2. Generate combined witness trace
        // 3. Prove via GKR (all txs in parallel)
        // 4. Aggregate into single STARK proof

        // Reuses: prove_gkr_simd_gpu() from gkr/prover.rs
        // Reuses: CommitmentSchemeProver from aggregation.rs
        // Reuses: PoseidonChannel for Fiat-Shamir
    }

    pub fn verify(proof: &BatchProof, public_inputs: &BatchPublicInputs) -> bool {
        // Single STARK verification
        // public_inputs contains all nullifiers + new commitments + merkle roots
    }
}
```

### 5.3 Public Inputs Structure

```rust
pub struct BatchPublicInputs {
    pub nullifiers: Vec<[M31; 4]>,          // one per input note consumed
    pub new_commitments: Vec<[M31; 4]>,     // one per output note created
    pub merkle_root: [M31; 4],              // note tree root at proof time
    pub asp_root: Option<[M31; 4]>,         // optional ASP association set root
    pub batch_hash: [M31; 4],               // Poseidon hash of all public inputs
}
```

### 5.4 GPU Integration

The batch circuit maps directly to existing CUDA kernels:

| Circuit Component | CUDA Kernel | File |
|---|---|---|
| Poseidon S-box muls | `m31_mul_kernel` | `gpu/forward_kernels.rs` |
| Poseidon MDS matmul | `m31_gemm_kernel` | `gpu/sumcheck_kernels.rs` |
| LogUp range proofs | Existing LogUp path | `gkr/prover.rs` |
| GKR sumcheck | `reduce_matmul_layer_gpu` | `gkr/prover.rs` |

No new CUDA kernels required. The existing GPU pipeline handles the privacy circuit natively.

### 5.5 Deliverables

- [ ] `PrivacyBatch::prove()` — batch 1,000 txs into single STARK
- [ ] `PrivacyBatch::verify()` — verify batch STARK proof
- [ ] `test_batch_10` — prove/verify 10 transactions
- [ ] `test_batch_100` — prove/verify 100 transactions
- [ ] `test_batch_1000` — prove/verify 1,000 transactions (benchmark)
- [ ] `bench_gpu_batch` — GPU throughput measurement

---

## 6. Phase 5: Starknet Pool Contract

**Goal**: Deploy the on-chain pool contract that manages the note tree, nullifier set, and proof verification.

### 6.1 Files to Create

| File | Action | Description |
|---|---|---|
| `Obelysk-Protocol/contracts/src/vm31_pool.cairo` | Create | Main pool contract |
| `Obelysk-Protocol/contracts/src/vm31_verifier.cairo` | Create | STARK proof verifier adapter |
| `Obelysk-Protocol/contracts/src/vm31_merkle.cairo` | Create | On-chain Poseidon-M31 Merkle tree |
| `Obelysk-Protocol/tests/test_vm31_pool.cairo` | Create | Integration tests |

### 6.2 Contract Interface

```cairo
#[starknet::interface]
trait IVM31Pool<TContractState> {
    // User operations
    fn deposit(ref self: TContractState, commitment: Span<felt252>, asset_id: felt252, amount: u256);
    fn spend(ref self: TContractState, proof: Span<felt252>, public_inputs: Span<felt252>);
    fn withdraw(ref self: TContractState, proof: Span<felt252>, recipient: ContractAddress, amount: u256, asset_id: felt252);

    // Batch operations (relayer)
    fn submit_batch(ref self: TContractState, proof: Span<felt252>, nullifiers: Span<Span<felt252>>, new_commitments: Span<Span<felt252>>, merkle_root: Span<felt252>);

    // ASP management
    fn update_asp_root(ref self: TContractState, asp_id: felt252, root: Span<felt252>);

    // View functions
    fn get_merkle_root(self: @TContractState) -> Span<felt252>;
    fn is_nullifier_spent(self: @TContractState, nullifier: Span<felt252>) -> bool;
    fn get_pool_size(self: @TContractState) -> u64;
}
```

### 6.3 M31 ↔ felt252 Encoding

On-chain data is stored as felt252. Each M31 value (31 bits) fits in felt252 with room to spare. QM31 values (4 M31 elements) are encoded as:

```cairo
// QM31 → felt252: pack 4 M31 values into 1 felt252
// Each M31 < 2^31, so 4 * 31 = 124 bits < 252 bits
fn pack_qm31(a: u32, b: u32, c: u32, d: u32) -> felt252 {
    a.into() + b.into() * 0x80000000 + c.into() * 0x4000000000000000 + d.into() * 0x200000000000000000000000
}

fn unpack_qm31(packed: felt252) -> (u32, u32, u32, u32) {
    // Extract 31-bit limbs
}
```

This allows a QM31 commitment to be stored as a single felt252 on-chain.

### 6.4 Verification Integration

The pool contract calls the existing `StwoVerifier` contract for proof verification:

```cairo
fn verify_batch_proof(ref self: ContractState, proof: Span<felt252>, public_inputs: Span<felt252>) -> bool {
    let verifier = IStwoVerifierDispatcher { contract_address: self.verifier_address.read() };
    verifier.verify_stark_proof(proof, public_inputs)
}
```

### 6.5 Deliverables

- [ ] `vm31_pool.cairo` — Main contract with deposit/spend/withdraw/batch
- [ ] `vm31_verifier.cairo` — Adapter to existing StwoVerifier
- [ ] `vm31_merkle.cairo` — On-chain Poseidon-M31 Merkle tree
- [ ] QM31 ↔ felt252 packing/unpacking utilities
- [ ] `test_deposit` — deposit and verify tree update
- [ ] `test_spend` — valid spend with nullifier tracking
- [ ] `test_double_spend` — duplicate nullifier rejection
- [ ] `test_batch_submit` — relayer batch submission
- [ ] Deployment script for Starknet Sepolia

---

## 7. Phase 6: Relayer Service

**Goal**: Build the off-chain relayer that aggregates transactions and submits batch proofs.

### 7.1 Architecture

```
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│  User Wallet  │───>│   Relayer    │───>│  Starknet    │
│  (encrypted   │    │  (GPU prover │    │  (pool       │
│   tx data)    │    │   + batcher) │    │   contract)  │
└──────────────┘    └──────────────┘    └──────────────┘
```

### 7.2 Components

| Component | Language | Description |
|---|---|---|
| Transaction API | Rust (axum) | REST API accepting encrypted transactions |
| Mempool | Rust | Priority queue of pending transactions |
| Batch builder | Rust | Assembles batches from mempool |
| Prover | Rust (stwo-ml) | GPU proving via existing pipeline |
| Submitter | Rust (starkli) | On-chain batch submission |

### 7.3 API

```
POST /api/v1/tx/submit
    Body: { encrypted_tx_data, fee_amount }
    Response: { tx_id, estimated_batch_time }

GET /api/v1/tx/{tx_id}/status
    Response: { status: "pending" | "proving" | "submitted" | "confirmed", batch_id }

GET /api/v1/pool/stats
    Response: { pool_size, pending_txs, last_batch_time, current_fee }
```

### 7.4 Deliverables

- [ ] REST API for transaction submission
- [ ] Mempool with fee-based priority ordering
- [ ] Batch builder with configurable batch size and timeout
- [ ] GPU prover integration (calls stwo-ml `PrivacyBatch::prove()`)
- [ ] Starknet submission via starkli or starknet-rs
- [ ] Monitoring dashboard (batch latency, GPU utilization, pool stats)

---

## 8. Phase 7: Client SDK and Wallet

**Goal**: TypeScript SDK for wallet integration — note management, scanning, transaction construction.

### 8.1 Components

| Component | Description |
|---|---|
| Key management | Spending key, view key derivation |
| Note scanner | Scan chain for incoming notes (view key decryption) |
| Transaction builder | Construct spend/deposit/withdraw witness data |
| Encryption | Encrypt transaction data for relayer submission |

### 8.2 Deliverables

- [ ] `@vm31/sdk` npm package
- [ ] Key derivation (spending key → owner_pubkey, view key)
- [ ] Note scanning (decrypt memos, identify owned notes)
- [ ] Transaction construction (select inputs, build witness)
- [ ] Relayer client (submit encrypted tx, poll status)
- [ ] Example wallet integration (React component)

---

## 9. Phase Dependencies

```
Phase 1 (Poseidon-M31)
    │
    ▼
Phase 2 (Crypto Primitives)
    │
    ├──────────────────┐
    ▼                  ▼
Phase 3 (Spend Circuit)  Phase 5 (Contract) ← parallel track
    │                  │
    ▼                  │
Phase 4 (Batch Proving) │
    │                  │
    ├──────────────────┘
    ▼
Phase 6 (Relayer)
    │
    ▼
Phase 7 (Client SDK)
```

Phases 3 and 5 can proceed in parallel after Phase 2. Phase 4 depends on Phase 3. Phase 6 depends on both Phase 4 (prover) and Phase 5 (contract). Phase 7 depends on Phase 6.

---

## 10. Testing Strategy

### 10.1 Test Levels

| Level | Scope | Count (est.) | Location |
|---|---|---|---|
| Unit | Individual primitives | ~50 | `crypto/*.rs` |
| Circuit | GKR circuit correctness | ~30 | `circuits/*.rs` |
| Integration | End-to-end prove/verify | ~20 | `tests/` |
| Contract | On-chain behavior | ~30 | `Obelysk-Protocol/tests/` |
| E2E | Full pipeline (relayer → chain) | ~10 | `tests/e2e/` |

### 10.2 Critical Test Cases

| Test | Phase | What It Validates |
|---|---|---|
| Poseidon-M31 reference vectors | 1 | Hash correctness against spec |
| Commitment hiding | 2 | Different blinding → different commitment |
| Nullifier uniqueness | 2 | Different keys → different nullifiers |
| Merkle proof roundtrip | 2 | Prove → verify for all tree positions |
| Valid spend proof | 3 | Honest transaction passes |
| Double-spend rejection | 3 | Same nullifier twice fails |
| Balance mismatch | 3 | Input sum != output sum fails |
| Wrong Merkle root | 3 | Outdated root fails |
| Batch 1,000 correctness | 4 | All txs in batch verified |
| Batch tamper detection | 4 | Single tampered tx invalidates batch |
| On-chain deposit/withdraw | 5 | Asset transfer + tree update |
| On-chain nullifier tracking | 5 | Double-spend prevention |
| Relayer censorship resistance | 6 | Alternative relayer accepts tx |

### 10.3 Security Audit Scope

Before mainnet deployment:
- [ ] Poseidon-M31 parameters reviewed by cryptographer
- [ ] MDS matrix security verification
- [ ] Spend circuit completeness review (no missing constraints)
- [ ] Smart contract audit (reentrancy, overflow, access control)
- [ ] Formal verification of nullifier uniqueness property

---

## 11. Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|---|---|---|---|
| Poseidon-M31 security issue | Critical | Low | Use established parameter generation, external review |
| GKR circuit soundness gap | Critical | Low | Extensive test suite, adversarial testing |
| Pool contract vulnerability | Critical | Medium | Professional audit before mainnet |
| Low adoption (empty pool) | High | Medium | Bootstrap incentives, cross-protocol integration |
| Regulatory action | High | Medium | ASP compliance layer, geographic restrictions |
| GPU centralization | Medium | Medium | CPU proving fallback (slower but decentralized) |
| Starknet gas price spike | Medium | Low | Batch size flexibility, multi-chain deployment |

---

## 12. Milestone Summary

| Milestone | Phases | Key Deliverable | Test Count |
|---|---|---|---|
| **M1: Crypto Foundation** | 1 + 2 | Poseidon-M31 + all primitives | ~80 |
| **M2: Privacy Prover** | 3 + 4 | Spend circuit + batch proving | ~50 |
| **M3: On-Chain MVP** | 5 | Pool contract on Sepolia | ~30 |
| **M4: Full Pipeline** | 6 + 7 | Relayer + client SDK | ~20 |
| **M5: Audit + Mainnet** | All | Security audit, mainnet deploy | — |

---

## 13. What We're NOT Building (Scope Boundaries)

To maintain focus, the following are explicitly out of scope for the initial release:

| Out of Scope | Reason | Future Phase |
|---|---|---|
| Custom L2 chain | Complexity; Starknet app-layer is sufficient | v2 |
| Cross-chain bridges | Requires cross-chain verification | v2 |
| Programmable privacy (smart contract + privacy) | Aztec-level composability is a separate problem | v2 |
| Mobile proving | GPU-only for now; CPU fallback planned later | v1.1 |
| Hardware wallet integration | Requires spending key export protocol | v1.1 |
| Multi-asset pool (single tree for all assets) | Separate trees per asset is simpler | v1.1 |

---

*VM31 / Obelysk Protocol v2 — February 2026*
